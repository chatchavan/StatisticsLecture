---
title: "Aligned Rank Transform - simple"
output: 
  html_notebook: 
    code_folding: hide
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)

####
# BEGIN: Chat's R header (revision: 15.04.17)
####

# The "pacman" package allows p_load() and p_load_gh() which
# automatically install missing packages and load them
if (!require("pacman")) install.packages("pacman", repos = 'https://stat.ethz.ch/CRAN/'); library(pacman)

p_load(
   car,        # grab bag of useful functions for NHST
   multcomp,   # for glht (planned comparison, post-hoc test)
   lme4,       # for multilevel linear model
   lmerTest,   # provides p-values for lmer()
   tidyverse,  # collection of the tidyverse packages (this automatically load the following):
   #dplyr,     #   - for data wrangling
   #tibble,    #   - a stricter alternative to data.frame
   #readr,     #   - a stricter alternative to read.csv
   #ggplot2,   #   - for plotting
   #tidyr,     #   - for data tidying
   #purrr,     #   - for functional programming
               # other packages in tidyverse that are non-core
   stringr,    #   - for string functions
   forcats,    #   - utility functions for working with factor levels
   broom,      #   - for cleaing output from models, e.g., lm()
   lubridate,  #   - utility for parsing and performing arithematic on dates 
               # extensions of tidyverse
   cowplot,    #   - adds plot_grid() to put multiple ggplot()'s togeter
   GGally,     #   - adds ggpairs() which is a smarter scatterplot matrix
               # 
               # visualization & interactivity
   Hmisc,      #   - for plotting mean and CI in ggplot
   rafalib,    #   - for imagemat function (visualize contrast codings)
   DT,         #   - for showing data table with navigation/search controls
               # testing:
   assertthat  #   - unit-testing functions
)

p_load_gh(
   "eclarke/ggbeeswarm" # beeswarm plot extension for ggplot2
)

# ggplot2 config (plot theme)
myTheme <- theme(
   panel.background = element_blank(), 
   panel.grid.major = element_line(color = "lightgrey", size = 0.2)
)

# DT config
options(DT.options = list(pageLength = 10))
options(DT.autoHideNavigation = TRUE)

# Hints:
# string interpolation: str_interp("${var}")
# options(digits=2)  # Decimal output readability, but may be problematic with rounding (default value = 7)

####
# END: Chat's R header
####


library(ARTool) # for art() and art.lm()
```

Data generator
```{r}
set.seed(12)
data <- tibble(
  Subject = c(rep(1:12, 3), rep(13:24, 3)),
  Interface = rep(c(1, 2), each = 36),
  Technique = rep(c("A", "B", "C", "A", "B", "C"), each = 12),
  Errors = round(c(
    rnorm(12, 21.5, 2),  # 1,A
    rnorm(12, 22, 2),  # 1,B
    rnorm(12, 23, 2),  # 1,C
    rnorm(12, 21, 3),  # 2,A
    rnorm(12, 22, 2),  # 2,B
    rnorm(12, 23, 2)   # 2,C
  ))
) %>% 
  dplyr::arrange(Subject, Interface, Technique)
data$Errors <- as.integer(data$Errors)
write_csv(data, "../data/interface_error.csv")

```

Load the data
```{r}
data <- read_csv("../data/interface_error.csv", col_types = "ccci")
data$Subject <- as.factor(data$Subject)
data$Interface <- as.factor(data$Interface)
data$Technique <- as.factor(data$Technique)
```

Inspect the experimental design
```{r}
data %>% 
  group_by(Interface, Technique) %>% 
  summarise(SubjectCount = length(Subject), SubjectIDs = str_c(unique(Subject), collapse=", "))
```


Plot the data for visual inspection
```{r, fig.height=3, fig.width=8}
pd <- position_dodge(width = 0.2)
p_interface <- data %>% 
  ggplot(aes(x = Interface, y = Errors, color = Technique, group = Technique)) +
  geom_point(alpha = 0.2, position = pd) +
  stat_summary(fun.y = "mean", geom = "line", position = pd) +
  stat_summary(fun.data = "mean_cl_normal", geom = "pointrange", position = pd)

p_technique <- data %>% 
  ggplot(aes(x = Technique, y = Errors, color = Interface, group = Interface)) +
  geom_point(alpha = 0.2, position = pd) +
  stat_summary(fun.y = "mean", geom = "line", position = pd) +
  stat_summary(fun.data = "mean_cl_normal", geom = "pointrange", position = pd)

plot_grid(p_interface, p_technique, nrow = 1)
```


# Parametric comparison
(assumptions are violated, but provided here for comparison)
```{r}
m_param <- lmer(Errors ~ Interface * Technique + (1|Subject), data=data)

# ANOVA
anova(m_param)

# pairwise comparison
mc_param_interface <- multcomp::glht(
  update(m_param, . ~  Technique + (1|Subject)),
  linfct = mcp(Technique = "Tukey"))
ci_param_interface <- tidy(confint(mc_param_interface))


# effect size Cohen's d (and CIs)
ci_param_interface$d <- ci_param_interface$estimate / sigmaHat(m_param)
ci_param_interface$d.conf.high <- ci_param_interface$conf.high / sigmaHat(m_param)
ci_param_interface$d.conf.low <- ci_param_interface$conf.low / sigmaHat(m_param)


# confidence interval
ci_param_interface
```



# Aligned Rank Transform
1. Run ART and verify appropriateness of ART (all values should be close to zero):
```{r}
m_art <- art(Errors ~ Interface * Technique + (1|Subject), data=data)
summary(m_art)
```

2. ANOVA
```{r}
anova_art <- anova(m_art)
anova_art
```


3. Pairwise comparison with ART results (in aligned ranks and in Cohen's d)

```{r}
m_art_interface <- artlm(m_art, "Technique")
mc_art_interface <- multcomp::glht(m_art_interface,
  linfct = mcp(Technique = "Tukey"))

# effect size of aligned rank (and CIs)
ci_art_interface <- tidy(confint(mc_art_interface))

# effect size Cohen's d (and CIs)
ci_art_interface$d <- ci_art_interface$estimate / sigmaHat(m_art_interface)
ci_art_interface$d.conf.high <- ci_art_interface$conf.high / sigmaHat(m_art_interface)
ci_art_interface$d.conf.low <- ci_art_interface$conf.low / sigmaHat(m_art_interface)

ci_art_interface
```




# Pairwise comparison with Wilcoxon signed rank test
```{r}

err_A <- data %>% dplyr::filter(Technique == "A") %>% .[["Errors"]]
err_B <- data %>% dplyr::filter(Technique == "B") %>% .[["Errors"]]
err_C <- data %>% dplyr::filter(Technique == "C") %>% .[["Errors"]]

my_conf <- 1 - (.05 / 3)
wilcox_result_t <- bind_rows(
  tidy(wilcox.test(err_B, err_A, paired = FALSE, conf.int = TRUE, conf.level = my_conf)),
  tidy(wilcox.test(err_C, err_A, paired = FALSE, conf.int = TRUE, conf.level = my_conf)),
  tidy(wilcox.test(err_C, err_B, paired = FALSE, conf.int = TRUE, conf.level = my_conf))
)
  
wilcox_result_t$lhs <- c("B - A", "C - A", "C - B")
```



# Graphical summary
```{r}
# common plot function
plot_ci <- function(ci_tidy, y_str, ymin_str, ymax_str, ylab_str) {
  ci_tidy %>% 
    ggplot(aes_string(
      x = "lhs", 
      y = y_str,
      ymin = ymin_str, 
      ymax = ymax_str
      )) +
    geom_hline(yintercept = 0, color = "red") +
    geom_point() +
    geom_errorbar(width = 0) +
    expand_limits(y = 0) +
    coord_flip() +
    ylab(ylab_str)
    # theme(
    #   axis.title.y = element_blank(),
    #   axis.text.y = element_blank(),
    #   axis.ticks.y = element_blank(),
    #   axis.line.y = element_blank())
}
```
```{r, fig.height=6, fig.width=4}
plot_grid(
  # parametric mean difference
  plot_ci(ci_param_interface, "estimate", "conf.low", "conf.high", "Mean differences (errors)"),
  plot_ci(ci_param_interface, "d", "d.conf.low", "d.conf.high", "Cohen's d of mean differences"),
  
  # ART (semi-parametric)
  plot_ci(ci_art_interface,   "estimate", "conf.low", "conf.high", "Aligned rank differences"),
  plot_ci(ci_art_interface,   "d", "d.conf.low", "d.conf.high", "Cohen's d of aligned rank differences"),
  
  # Wilcoxon signed-rank test (non-parametric)
  plot_ci(wilcox_result_t,    "estimate", "conf.low", "conf.high", "Median of the differences (errors)"),
  ncol = 2
)
  
```
Noteable points

* For C - B, it seems that ART has higher statistical power (yielding Cohen's *d* that exclude zero)
* But for B - A, parametric method yieds slightly higher Cohen's *d* (more than 1.0)
* For the Wilcoxon's median of the differences, note that the 95% CIs are asymmetric. This results in the effect slightly stronger than parametric method in C - A. But this could results from ties and zero-differences (non-exact p-values and CIs were computed).
