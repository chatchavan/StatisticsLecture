---
title: "Statistical assumptions"
output: 
  html_notebook: 
    code_folding: hide
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)

####
# BEGIN: Chat's R header (revision: 15.04.17)
####

# The "pacman" package allows p_load() and p_load_gh() which
# automatically install missing packages and load them
if (!require("pacman")) install.packages("pacman", repos = 'https://stat.ethz.ch/CRAN/'); library(pacman)

p_load(
   car,        # grab bag of useful functions for NHST
   multcomp,   # for glht (planned comparison, post-hoc test)
   lme4,       # for multilevel linear model
   lmerTest,   # provides p-values for lmer()
   tidyverse,  # collection of the tidyverse packages (this automatically load the following):
   #dplyr,     #   - for data wrangling
   #tibble,    #   - a stricter alternative to data.frame
   #readr,     #   - a stricter alternative to read.csv
   #ggplot2,   #   - for plotting
   #tidyr,     #   - for data tidying
   #purrr,     #   - for functional programming
               # other packages in tidyverse that are non-core
   stringr,    #   - for string functions
   forcats,    #   - utility functions for working with factor levels
   broom,      #   - for cleaing output from models, e.g., lm()
   lubridate,  #   - utility for parsing and performing arithematic on dates 
               # extensions of tidyverse
   cowplot,    #   - adds plot_grid() to put multiple ggplot()'s togeter
   GGally,     #   - adds ggpairs() which is a smarter scatterplot matrix
               # 
               # visualization & interactivity
   Hmisc,      #   - for plotting mean and CI in ggplot
   rafalib,    #   - for imagemat function (visualize contrast codings)
   DT,         #   - for showing data table with navigation/search controls
               # testing:
   assertthat  #   - unit-testing functions
)

p_load_gh(
   "eclarke/ggbeeswarm" # beeswarm plot extension for ggplot2
)

# ggplot2 config (plot theme)
myTheme <- theme(
   panel.background = element_blank(), 
   panel.grid.major = element_line(color = "lightgrey", size = 0.2)
)

# DT config
options(DT.options = list(pageLength = 10))
options(DT.autoHideNavigation = TRUE)

# Hints:
# string interpolation: str_interp("${var}")
# options(digits=2)  # Decimal output readability, but may be problematic with rounding (default value = 7)

####
# END: Chat's R header
####


p_install(c(
  "nortest", # for lillie.test(): The Kolmogorov-Smirnov test with a correct p-value
  "fGarch"   # for rsnorm(): generating skewed distributions
  ))


```


# Normality assumption
The residuals are normally distributed.

## Two samples (e.g., in t-test)
```{r}
# example data
n <- 40
x1 <- rnorm(n, mean = 5, sd = 2)
x2 <- rnorm(n, mean = 10, sd = 2)

# calculate the difference
diff <- x1 - x2
```

QQ plot:

```{r}
car::qqPlot(diff)
```

* The vertical axis is the same as the horizontal axis in the plot of (x1 - x2) above.
* The points are sorted residuals.
* The horizontal axis is the quantile.
* The line indicates perfect normal distribution.
* The points should stay near the line.


Kolmogorov-Smirnov test:
```{r}
nortest::lillie.test(diff)
```

* H0: (x1 - x2) are normally distributed.
* p-value more than .05 means the assumption is not violated.

## Linear model (categorical independent variable)
Fit the model and analyze the residuals (of the whole model altogether) with the procedure above.
```{r}
# example data
n <- 100
data <- tibble(
  x = as.factor(rep(c("A", "B", "C"), each = n)),
  y = c(
    rnorm(n, mean = 5),  # normally distributed
    
    fGarch::rsnorm(n, mean = 8, sd = 1, xi = 0.1),
    fGarch::rsnorm(n, mean = 10, sd = 1, xi = 20) 
    
    # NOTE: xi parameter is a positive value.
    # xi = 1: normal distribution (equal tail)
    # 0 < xi < 1: negative skew (left tail is longer)
    # 1 < xi: positive skew (right tail is longer)
  )
)

# model
m1 <- lm(y ~ x, data = data)

# add residuals and prediction to the data
data %>%
  modelr::add_predictions(m1) %>% 
  modelr::add_residuals(m1) ->
  data_aug

# plot model and residuals
data_aug %>%   
  ggplot(aes(x = x, y = y)) +
  geom_beeswarm() +
  geom_point(aes(y = pred), color = "red", shape = 18, size = 3) ->
  p_fit

data_aug %>%   
  ggplot(aes(x = x, y = resid)) +
  geom_beeswarm() +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") ->
  p_resid

plot_grid(p_fit, p_resid, nrow = 1)
```
```{r}
car::qqPlot(data_aug$resid)
nortest::lillie.test(data_aug$resid)
```



## Linear model (continous independent variable)
Same procedure as above
```{r}
# example data
n <- 100
x <- rnorm(n, mean = 5)
data_cont <- tibble(
  x = x,
  y = 2 + x * fGarch::rsnorm(n, mean = 8, sd = 0.5, xi = -3)
)

# model
m_cont <- lm(y ~ x, data = data_cont)

# add residuals and prediction to the data
data_cont %>%
  modelr::add_predictions(m_cont) %>% 
  modelr::add_residuals(m_cont) ->
  data_cont_aug

# plot model and residuals
data_cont_aug %>%   
  ggplot(aes(x = x, y = y)) +
  geom_beeswarm() +
  geom_point(aes(y = pred), color = "red", shape = 18, size = 3) ->
  p_fit_cont

data_cont_aug %>%   
  ggplot(aes(x = x, y = resid)) +
  geom_beeswarm() +
  geom_hline(yintercept = 0, color = "red", linetype = "dashed") ->
  p_resid_cont

plot_grid(p_fit_cont, p_resid_cont, nrow = 1)
```

```{r}
car::qqPlot(data_aug$resid)
nortest::lillie.test(data_aug$resid)
```

